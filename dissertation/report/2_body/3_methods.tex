\section{Methods}

\begin{enumerate}
    \item What are you doing?
          \begin{enumerate}
              \item Building locally with NetworkX
              \item Building stream algorithms using a file stream
              \item Building stream algorithms with an enterprise stream solution
              \item Datasets and file formats
              \item Memory profiling
              \item Runtime analysis
          \end{enumerate}
    \item How are you doing it?
          \begin{itemize}
              \item Detailed explanation of method
          \end{itemize}
    \item Why are you doing it this way?
          \begin{itemize}
              \item Should probably be merged with the above
          \end{itemize}
\end{enumerate}

\subsubsection{Branching - Non-Stream}

\begin{algorithm}[H]
    \caption{Branching - Non-Stream}
    \DontPrintSemicolon
    \SetKwFunction{FBranching}{branching}
    \SetKwFunction{FEdges}{numberOfEdges}
    \SetKwFunction{FCopy}{copy}
    \SetKwFunction{FFirstEdge}{firstEdge}
    \SetKwFunction{FRemoveNode}{removeNode}
    \SetKwFunction{FAdd}{add}

    \KwInput{Graph $graph$ to calculate vertex cover on}
    \KwInput{Value $k$ for maximum size of vertex cover}
    \KwOutput{Vertex cover of maximum size $k$ if one exists}
    \Func{\FBranching{graph\textnormal{: Graph, }k\textnormal{: int, }vertexCover\textnormal{: set}}}{
        \If{\FEdges{graph} $= 0$}{
            \Return vertexCover
        }
        \If{k $= 0$}{
            \Return Null
        }
        $u, v \gets$ \FFirstEdge{graph}\;
        \tcp{Run recursively on left side}
        $leftGraph \gets$ \FCopy{graph}\;
        \FRemoveNode{leftGraph, u}\;
        $leftVertexCover \gets$ \FCopy{vertexCover}\;
        \FAdd{leftVertexCover, u}\;
        $leftVertexCover \gets$ \FBranching{leftGraph, k - 1, leftVertexCover}\;

        \If{leftVertexCover \KwIs \KwNot Null}{
            \Return leftVertexCover
        }

        \tcp{Run recursively on right side}
        $rightGraph \gets$ \FCopy{graph}\;
        \FRemoveNode{rightGraph, u}\;
        $rightVertexCover \gets$ \FCopy{vertexCover}\;
        \FAdd{rightVertexCover, u}\;
        $rightVertexCover \gets$ \FBranching{rightGraph, k - 1, rightVertexCover}\;
        \Return rightVertexCover
    }

\end{algorithm}

\subsubsection{Branching - Stream}

\begin{algorithm}[H]
    \caption{Branching - Stream}
    \DontPrintSemicolon
    \SetKwFunction{FCalculateVC}{calculateVC}
\end{algorithm}

\subsubsection{Kernelization - Non-Stream}

\begin{algorithm}[H]
    \caption{Kernelization - Non-Stream}
    \DontPrintSemicolon
    \SetKwFunction{FKernelize}{kernelize}
    \SetKwFunction{FCopy}{copy}
    \SetKwFunction{FDegree}{degree}

    \KwInput{Graph $graph$ to calculate vertex cover on}
    \KwInput{Value $k$ for maximum size of vertex cover}
    \KwOutput{Kernel of graph and vertex cover}
    \Func{\FKernelize{graph\textnormal{: Graph, }k\textnormal{ : int}}}{
        $kernel \gets$ \FCopy{graph}\;
        $vertexCover$ : set\;
        $reductionsCanBeMade \gets$ True\;
        \While{reductionsCanBeMade}{
            $reductionMade \gets$ False\;
            \For{$node$ \KwIn $kernel$.nodes}{
                \uIf{k > $0$ \KwAnd \FDegree{node} > k}{
                    $reductionMade \gets$ False\;
                    $kernel$.removeNode($node$)\;
                    $vertexCover$.add($node$)\;
                    $k \gets k - 1$\;
                }
                \ElseIf{\FDegree{node} = 0}{
                    $kernel$.removeNode($node$)\;
                }
            }
            \If{\KwNot reductionMade}{
                $reductionsCanBeMade \gets$ False\;
            }
        }
        \Return kernel, vertexCover\;
    }
\end{algorithm}

\subsubsection{Kernelization - Stream}

\begin{algorithm}[H]
    \caption{Kernelization - Stream}
    \DontPrintSemicolon
    \SetKwFunction{FInit}{init}
    \SetKwFunction{FNext}{next}
    \SetKwFunction{FNeighbours}{neighbours}
    \SetKwFunction{FLen}{length}

    \KwInput{Edges $u$, $v$ from a stream}
    \KwInput{Value $k$ for maximum size of vertex cover}
    \KwOutput{Boolean whether kernel exists}
    \KwData{$k$, $matchings$}
    \Func{\FInit{k\textnormal{: int}}}{
        $k$ : int $\leftarrow$ $k$\;
        $matchings$ : dict\;
    }
    \Func{\FNext{u, v}}{
        $isNeighbour$ : bool $\gets$ False\;
        \If{u $\KwIs$ $\KwIn$ matchings $\KwAnd$ $\FLen{\FNeighbours{u}}$ $\leq$ k}{
            matchings$[u]$.append((u,v))\;
            isNeighbour $\gets$ True\;
        }
        \If{v $\KwIs$ $\KwIn$ matchings $\KwAnd$ $\FLen{\FNeighbours{v}}$ $\leq$ k}{
            $matchings[v]$.append($(u,v)$)\;
            $isNeighbour$ $\gets$ True\;
        }
        \If{$\KwNot$ $isNeighbour$}{
            $matchings$.append((u,v))\;
            \If{$\FLen{matchings}$ $>$ k}{
                \Return False\;
            }
        }
        \Return True\;
    }
\end{algorithm}

\subsection{What I Plan To Do}

\subsection{How I Plan To Do It}

\subsubsection{Python timing}

\begin{itemize}
    \item perf\_counter
    \item process\_time
    \item time
    \item monotonic
\end{itemize}
