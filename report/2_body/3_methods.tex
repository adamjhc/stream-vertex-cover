\section{Methods}

\begin{enumerate}
    \item What are you doing?
          \begin{enumerate}
              \item Testing locally in a non-streaming environment
              \item Migrating to a streaming environment
              \item Testing with synthetic datasets
              \item Testing with real world datasets
              \item Optimisations?
          \end{enumerate}
    \item How are you doing it?
          \begin{itemize}
              \item Detailed explanation of method
          \end{itemize}
    \item Why are you doing it this way?
          \begin{itemize}
              \item Should probably be merged with the above
          \end{itemize}
\end{enumerate}

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetKwFunction{FInit}{Init}
    \SetKwFunction{FNext}{Next}
    \SetKwFunction{FNeighbours}{Neighbours}
    \SetKwFunction{FLen}{Len}
    \SetKw{KwIs}{is}
    \SetKw{KwIn}{in}
    \SetKw{KwNot}{not}
    \SetKw{KwAnd}{and}

    \KwInput{Edges $u$, $v$ from a stream}
    \KwInput{Value $k$ for maximum size of vertex cover}
    \KwOutput{Boolean whether kernel exists}
    \KwData{$k$, matchings}
    \Func{\FInit{k: \textnormal{int}}}{
        $k$ : int $\leftarrow$ $k$\;
        $matchings$ : dict $\gets$ Dictionary\;
    }
    \Func{\FNext{u, v}}{
        $isNeighbour$ : bool $\gets$ False\;
        \If{u $\KwIs$ $\KwIn$ matchings $\KwAnd$ $\FLen{\FNeighbours{u}}$ $\leq$ k}{
            matchings$[u]$.append((u,v))\;
            isNeighbour $\gets$ True\;
        }
        \If{v $\KwIs$ $\KwIn$ matchings $\KwAnd$ $\FLen{\FNeighbours{v}}$ $\leq$ k}{
            $matchings[v]$.append($(u,v)$)\;
            $isNeighbour$ $\gets$ True\;
        }
        \If{$\KwNot$ $isNeighbour$}{
            $matchings$.append((u,v))\;
            \If{$\FLen{matchings}$ $>$ k}{
                \Return False\;
            }
        }
        \Return True\;
    }
    \caption{Kernelization}
\end{algorithm}

\subsection{What I Plan To Do}

\subsection{How I Plan To Do It}

\subsubsection{Python timing}

\begin{itemize}
    \item perf\_counter
    \item process\_time
    \item time
    \item monotonic
\end{itemize}
