\section{Methods}

\begin{enumerate}
    \item What are you doing?
          \begin{enumerate}
              \item Testing locally in a non-streaming environment
              \item Migrating to a streaming environment
              \item Testing with synthetic datasets
              \item Testing with real world datasets
              \item Optimisations?
          \end{enumerate}
    \item How are you doing it?
          \begin{itemize}
              \item Detailed explanation of method
          \end{itemize}
    \item Why are you doing it this way?
          \begin{itemize}
              \item Should probably be merged with the above
          \end{itemize}
\end{enumerate}

\subsubsection{Branching - Non-Stream}

\begin{algorithm}[H]
    \caption{Branching - Non-Stream}
    \DontPrintSemicolon
\end{algorithm}

\subsubsection{Branching - Stream}

\begin{algorithm}[H]
    \caption{Branching - Stream}
    \DontPrintSemicolon
    \SetKwFunction{FCalculateVC}{calculateVC}
\end{algorithm}

\subsubsection{Kernelization - Non-Stream}

\begin{algorithm}[H]
    \caption{Kernelization - Non-Stream}
    \DontPrintSemicolon
    \SetKwFunction{FKernelize}{kernelize}
    \SetKwFunction{FCopy}{copy}

    \KwInput{Graph $graph$ to calculate vertex cover on}
    \KwInput{Value $k$ for maximum size of vertex cover}
    \KwOutput{Kernel of graph and vertex cover}
    \Func{\FKernelize{graph\textnormal{: Graph, }k\textnormal{ : int}}}{
        $kernel \gets$ \FCopy{graph}\;
        $vertexCover$ : set\;
        $reductionsCanBeMade \gets$ True\;
        \While{reductionsCanBeMade}{
            $reductionMade \gets$ False\;
            \For{$node$ \KwIn $kernel$.nodes}{
                \uIf{k > $0$ \KwAnd node.degree > k}{
                    $reductionMade \gets$ False\;
                    $kernel$.removeNode($node$)\;
                    $vertexCover$.add($node$)\;
                    $k \gets k - 1$\;
                }
                \ElseIf{node.degree = 0}{
                    $kernel$.removeNode($node$)\;
                }
            }
            \If{\KwNot reductionMade}{
                $reductionsCanBeMade \gets$ False\;
            }
        }
        \Return kernel, vertexCover\;
    }
\end{algorithm}

\subsubsection{Kernelization - Stream}

\begin{algorithm}[H]
    \caption{Kernelization - Stream}
    \DontPrintSemicolon
    \SetKwFunction{FInit}{init}
    \SetKwFunction{FNext}{next}
    \SetKwFunction{FNeighbours}{neighbours}
    \SetKwFunction{FLen}{length}

    \KwInput{Edges $u$, $v$ from a stream}
    \KwInput{Value $k$ for maximum size of vertex cover}
    \KwOutput{Boolean whether kernel exists}
    \KwData{$k$, $matchings$}
    \Func{\FInit{k\textnormal{: int}}}{
        $k$ : int $\leftarrow$ $k$\;
        $matchings$ : dict\;
    }
    \Func{\FNext{u, v}}{
        $isNeighbour$ : bool $\gets$ False\;
        \If{u $\KwIs$ $\KwIn$ matchings $\KwAnd$ $\FLen{\FNeighbours{u}}$ $\leq$ k}{
            matchings$[u]$.append((u,v))\;
            isNeighbour $\gets$ True\;
        }
        \If{v $\KwIs$ $\KwIn$ matchings $\KwAnd$ $\FLen{\FNeighbours{v}}$ $\leq$ k}{
            $matchings[v]$.append($(u,v)$)\;
            $isNeighbour$ $\gets$ True\;
        }
        \If{$\KwNot$ $isNeighbour$}{
            $matchings$.append((u,v))\;
            \If{$\FLen{matchings}$ $>$ k}{
                \Return False\;
            }
        }
        \Return True\;
    }
\end{algorithm}

\subsection{What I Plan To Do}

\subsection{How I Plan To Do It}

\subsubsection{Python timing}

\begin{itemize}
    \item perf\_counter
    \item process\_time
    \item time
    \item monotonic
\end{itemize}
